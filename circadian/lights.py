# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_lights.ipynb.

# %% auto 0
__all__ = ['Light', 'make_pulse', 'get_pulse']

# %% ../nbs/01_lights.ipynb 3
import warnings
import numpy as np
import pylab as plt
from typing import Callable
from matplotlib.pyplot import step
from fastcore.basics import patch_to
from numpy.core.fromnumeric import repeat

# %% ../nbs/01_lights.ipynb 5
class Light:
    "Helper class for creating light schedules"
    def __init__(self, 
                 light: Callable, # light function that takes in a time value and returns a float, if a float is passed, then the light function is a constant set to that lux value 
                 start_time: float=0.0, # when the light function starts in hours
                 duration: float=1.0, # duration of the light function in hours. Must be positive
                 default_value: float=0.0, # the default value of the light function outside of its duration. Must be nonnegative
                 ):
        # start_time type checking
        start_time_err_msg = "`start_time` should be a `float`"
        try:
            start_time = float(start_time)
        except:
            # catches when start_time can't be converted to a float
            raise ValueError(start_time_err_msg)

        # duration type and value checking
        duration_err_msg = "`duration` should be a positive `float`"
        try:
            duration = float(duration)
            if duration <= 0:
                raise ValueError(duration_err_msg)
        except:
            # catches when duration can't be converted to a float
            raise ValueError(duration_err_msg)

        # default_value type and value checking
        default_value_err_msg = "`default_value` should be a nonnegative `float`"
        try:
            default_value = float(default_value)
            if default_value < 0:
                raise ValueError(default_value_err_msg)
        except: 
            # catches when default_value can't be converted to a float
            raise ValueError(default_value_err_msg)

        # light type checking 
        light_input_err_msg = "`light` should be a nonnegative `float`, or a callable with a single `float` parameter which returns a nonnegative `float`"
        if not callable(light):
            try:
                light = float(light)
            except:
                # catches when the provided light value can't be converted to a float
                raise ValueError(light_input_err_msg)

        # create light function
        def light_fn(t):
            default_zone = (t < start_time) | (t > start_time + duration)
            light_zone = (t >= start_time) & (t <= start_time + duration)
            conditions = [default_zone, light_zone]
            if callable(light):
                values = [default_value, light(t)]
            else:
                values = [default_value, light]
            return np.piecewise(t, conditions, values)

        light_fn = np.vectorize(light_fn, otypes=[float])

        # check that the light function returns values that can be cast to float
        test_output = light_fn(start_time + duration/2.0)
        try:
            float(test_output)
        except:
            # catches when the function created from light does not return values that can be cast to float
            raise ValueError(light_input_err_msg)

        # check that the light function returns nonnegative values
        if np.any(light_fn(np.linspace(start_time, start_time + duration, 100)) < 0):
            raise ValueError(light_input_err_msg)

        # assign attributes
        self._func = light_fn
        self.duration = duration
        self.start_time = start_time
        self.default_value = default_value

# %% ../nbs/01_lights.ipynb 8
@patch_to(Light, as_prop=True)
def end_time(self: Light):
    "End time of the active portion of the light function"
    return self.start_time + self.duration

# %% ../nbs/01_lights.ipynb 10
@patch_to(Light)
def __call__(self, 
             t: np.ndarray, # time values in hours to evaluate the light function
             repeat_period: float=None, # if not None, the light function will repeat every `repeat_period` hours
             ):
    # t type checking
    t_err_msg = "`t` should be a `float` or a 1d `numpy.ndarray` of `float`"
    try:
        t = np.array(t, dtype=float)
        if t.ndim == 0:
            try:
                t = float(t)
                t = np.array([t])
            except:
                # catches when t can't be converted to a float
                raise ValueError(t_err_msg)
        elif t.ndim != 1:
            # catches when t is not a 1d array
            raise ValueError(t_err_msg)
    except:
        raise ValueError(t_err_msg)

    # repeat_period type and value checking
    repeat_period_err_msg = "`repeat_period` should be a positive `float`"
    if repeat_period is not None:
        try:
            repeat_period = float(repeat_period)
            if repeat_period <= 0:
                raise ValueError(repeat_period_err_msg)
        except:
            # catches when repeat_period can't be converted to a float
            raise ValueError(repeat_period_err_msg)

    if repeat_period is not None:
        t = np.mod(t, repeat_period)
    
    return self._func(t)

# %% ../nbs/01_lights.ipynb 12
@patch_to(Light)
def __add__(self, 
            light_obj: 'Light' # another light object to be added to the current light object
            ):
    start_times = [self.start_time, light_obj.start_time]
    end_times = [self.end_time, light_obj.end_time]
    default_values = [self.default_value, light_obj.default_value]

    # catch the edge case when light functions only overlap for a single point
    is_overlap_a_point = max(start_times) == min(end_times)
    if is_overlap_a_point:
        overlap_value = self._func(max(start_times))

    new_start_time = min(start_times)
    new_duration = max(end_times) - new_start_time
    new_default_value = sum(default_values)

    def new_light_fn(t):
        fn_1 = self._func(t)
        fn_2 = light_obj._func(t)
        if is_overlap_a_point:
            if t == max(start_times):
                return overlap_value
            else:
                return fn_1 + fn_2
        else:
            return fn_1 + fn_2

    return Light(new_light_fn, start_time=new_start_time, duration=new_duration, default_value=new_default_value)

# %% ../nbs/01_lights.ipynb 14
@patch_to(Light)
def plot(self, 
         plot_start_time: float = None, # start time of the plot in hours
         plot_end_time: float = None, # end time of the plot in hours
         repeat_period: float = None, # period of the plot in hours
         num_samples: int=10000, # number of samples to plot
         ax=None, # matplotlib axis to plot on
         *args, # arguments to pass to matplotlib.pyplot.plot
         **kwargs # keyword arguments to pass to matplotlib.pyplot.plot
         ):
    "Plot the light function between `start_time` and `end_time` with `num_samples` samples"
    # type checking
    if plot_start_time is not None:
        if not isinstance(plot_start_time, (float, int)):
            raise ValueError(f"plot_start_time must be a float or int, got {type(plot_start_time)}")
    if plot_end_time is not None:
        if not isinstance(plot_end_time, (float, int)):
            raise ValueError(f"plot_end_time must be a float or int, got {type(plot_end_time)}")
    if repeat_period is not None:
        if not isinstance(repeat_period, (float, int)):
            raise ValueError(f"repeat_period must be a float or int, got {type(repeat_period)}")
    if ax is not None:
        if not isinstance(ax, plt.Axes):
            raise ValueError(f"ax must be a matplotlib Axes object, got {type(ax)}")
    if num_samples is not None:
        if not isinstance(num_samples, int):
            raise ValueError(f"num_samples must be an int, got {type(num_samples)}")
    
    if plot_start_time is None:
        plot_start_time = self.start_time
    if plot_end_time is None:
        plot_end_time = self.end_time
        
    t = np.linspace(plot_start_time, plot_end_time, num_samples)
    vals = self.__call__(t, repeat_period=repeat_period)
    if ax is None:
        plt.figure()
        ax = plt.gca()

    ax.plot(t, vals, *args, **kwargs)
    return ax

# %% ../nbs/01_lights.ipynb 19
@patch_to(Light)
def RegularLight(lux: float=150.0, # lux intensity of the light
                 lights_on: float=7.0, # hour of the day for lights to come on
                 lights_off: float=23.0, # hour of the day for lights to go off
                 ) -> 'Light':
    "Create a light schedule with a `lux` value from `lights_on` to `lights_off` on a 24 hour schedule"
    # type checking
    if not isinstance(lux, (float, int)):
        raise ValueError(f"lux must be a nonnegative float or int, got {type(lux)}")
    elif lux < 0.0:
        raise ValueError(f"lux must be a nonnegative float or int, got {lux}")
    if not isinstance(lights_on, (float, int)):
        raise ValueError(f"lights_on must be a float or int, got {type(lights_on)}")
    elif lights_on < 0.0 or lights_on > 24.0:
        raise ValueError(f"lights_on must be between 0.0 and 24.0, got {lights_on}")
    if not isinstance(lights_off, (float, int)):
        raise ValueError(f"lights_off must be a float or int, got {type(lights_off)}")
    elif lights_off < 0.0 or lights_off > 24.0:
        raise ValueError(f"lights_off must be between 0.0 and 24.0, got {lights_off}")
    
    lights_on = np.mod(lights_on, 24.0)
    lights_off = np.mod(lights_off, 24.0)
    if lights_off > lights_on:
        return Light(lux, start_time=lights_on, duration=lights_off - lights_on)
    else:
        first_light = Light(lux, start_time=0.0, duration=lights_off)
        second_light = Light(lux, start_time=lights_on, duration=24.0 - lights_on)
        return first_light + second_light

# %% ../nbs/01_lights.ipynb 21
@patch_to(Light)
def ShiftWorkLight(lux: float=150.0, # lux intensity of the light. Must be a nonnegative float or int
                   days_on: int=5, # number of days on the night shift. Must be a positive int
                   days_off: int=2, # number of days off shift. Must be a positive int
                   lights_on_workday: float=17.0, # hour of the day for lights to come on on a workday. Must be between 0.0 and 24.0
                   lights_off_workday: float=9.0, # hour of the day for lights to go off on a workday. Must be between 0.0 and 24.0
                   lights_on_day_off: float=9.0, # hour of the day for lights to come on on a day off. Must be between 0.0 and 24.0
                   lights_off_day_off: float=24.0, # hour of the day for lights to go off on a day off. Must be between 0.0 and 24.0
                   ) -> 'Light':
    "Create a light schedule for a shift worker" 
    # type checking
    lux_err_msg = "lux must be a nonnegative float or int, got "
    if not isinstance(lux, (float, int)):
        raise ValueError(lux_err_msg + f"{type(lux)}")
    elif lux < 0.0:
        raise ValueError(lux_err_msg + f"{lux}")
    days_on_err_msg = "days_on must be a positive int, got "
    if not isinstance(days_on, int):
        raise ValueError(days_on_err_msg + f"{type(days_on)}")
    elif days_on <= 0:
        raise ValueError(days_on_err_msg + f"{days_on}")
    days_off_err_msg = "days_off must be a positive int, got "
    if not isinstance(days_off, int):
        raise ValueError(days_off_err_msg + f"{type(days_off)}")
    elif days_off <= 0:
        raise ValueError(days_off_err_msg + f"{days_off}")
    lights_on_workday_err_msg = "lights_on_workday must be a float or int between 0.0 and 24.0, got "
    if not isinstance(lights_on_workday, (float, int)):
        raise ValueError(lights_on_workday_err_msg + f"{type(lights_on_workday)}")
    elif lights_on_workday < 0.0 or lights_on_workday > 24.0:
        raise ValueError(lights_on_workday_err_msg + f"{lights_on_workday}")
    lights_off_workday_err_msg = "lights_off_workday must be a float or int between 0.0 and 24.0, got "
    if not isinstance(lights_off_workday, (float, int)):
        raise ValueError(lights_off_workday_err_msg + f"{type(lights_off_workday)}")
    elif lights_off_workday < 0.0 or lights_off_workday > 24.0:
        raise ValueError(lights_off_workday_err_msg + f"{lights_off_workday}")
    lights_on_day_off_err_msg = "lights_on_day_off must be a float or int between 0.0 and 24.0, got "
    if not isinstance(lights_on_day_off, (float, int)):
        raise ValueError(lights_on_day_off_err_msg + f"{type(lights_on_day_off)}")
    elif lights_on_day_off < 0.0 or lights_on_day_off > 24.0:
        raise ValueError(lights_on_day_off_err_msg + f"{lights_on_day_off}")
    lights_off_day_off_err_msg = "lights_off_day_off must be a float or int between 0.0 and 24.0, got "
    if not isinstance(lights_off_day_off, (float, int)):
        raise ValueError(lights_off_day_off_err_msg + f"{type(lights_off_day_off)}")
    elif lights_off_day_off < 0.0 or lights_off_day_off > 24.0:
        raise ValueError(lights_off_day_off_err_msg + f"{lights_off_day_off}")
    
    # start already on the shift if lights_on_workday > lights_off_workday
    if lights_on_workday > lights_off_workday:
        total_schedule = Light(lux, start_time=0.0, duration=lights_off_workday)
    # define light start times for each work day, except last day because that's a transition day
    start_times_workdays = np.arange(1, days_on-1) * 24.0 + lights_on_workday
    if lights_on_workday > lights_off_workday:
        light_duration_workdays = 24.0 - lights_on_workday + lights_off_workday 
        total_schedule += Light(lux, start_time=lights_on_workday, duration=light_duration_workdays)
    else:
        light_duration_workdays = lights_off_workday - lights_on_workday
        total_schedule = Light(lux, start_time=lights_on_workday, duration=light_duration_workdays)
    # add workdays to total schedule
    for start_time in start_times_workdays:
        total_schedule += Light(lux, start_time=start_time, duration=light_duration_workdays)
    # transition from workday to day off. Sleep half of the time between `lights_on_workday` and `lights_on_day_off`
    work_to_off_duration = (24.0 - lights_on_workday + lights_on_day_off) / 2.0
    work_to_off_start = start_times_workdays[-1] + 24.0 
    total_schedule += Light(lux, start_time=work_to_off_start, duration=work_to_off_duration)
    # add days off to total schedule
    # get current day number
    start_times_days_off = np.arange(days_off-1) * 24.0 + lights_on_day_off + days_on * 24
    if lights_on_day_off > lights_off_day_off:
        light_duration_days_off = 24.0 - lights_on_day_off + lights_off_day_off
    else:
        light_duration_days_off = lights_off_day_off - lights_on_day_off
    for start_time in start_times_days_off:
        total_schedule += Light(lux, start_time=start_time, duration=light_duration_days_off)
    # transition from day off to workday. Sleep in two chunks between `lights_off_day_off` and `lights_on_workday`
    last_sleep_day_off = start_times_days_off[-1] + light_duration_days_off
    wake_time_workday = (days_on + days_off - 1) * 24 + lights_on_workday
    off_to_work_duration = (wake_time_workday - last_sleep_day_off) / 3.0
    off_to_work_start = last_sleep_day_off + off_to_work_duration
    total_schedule += Light(lux, start_time=off_to_work_start, duration=off_to_work_duration)
    # complete the schedule to make it periodic with period 24*(days_on + days_off)
    final_work_duration = (days_on + days_off) * 24.0 - wake_time_workday
    total_schedule += Light(lux, start_time=wake_time_workday, duration=final_work_duration)
    
    return total_schedule

# %% ../nbs/01_lights.ipynb 46
@patch_to(Light)
def SlamShift(lux: float=150.0, # lux intensity of the light
              shift: float=8.0, # number of hours to shift the light schedule
              before_days: int=10, #number of days before the shift occurs 
              after_days: int=10, # number of days after the shift occurs
              starting_lights_on: float=8.0 # hour of the day for lights to come on
              ) -> 'Light':
    "Create a light schedule for a shift worker under a slam shift" 
    # type checking
    if not isinstance(lux, (float, int)):
        raise ValueError(f"lux must be a nonnegative float or int, got {type(lux)}")
    elif lux < 0.0:
        raise ValueError(f"lux must be a nonnegative float or int, got {lux}")
    if not isinstance(shift, (float, int)):
        raise ValueError(f"shift must be a nonnegative float or int, got {type(shift)}")
    elif shift < 0.0:
        raise ValueError(f"shift must be a nonnegative float or int, got {shift}")
    if not isinstance(before_days, int):
        raise ValueError(f"before_days must be a nonnegative int, got {type(before_days)}")
    elif before_days < 0:
        raise ValueError(f"before_days must be a nonnegative int, got {before_days}")
    if not isinstance(after_days, int):
        raise ValueError(f"after_days must be a nonnegative int, got {type(after_days)}")
    elif after_days < 0:
        raise ValueError(f"after_days must be a nonnegative int, got {after_days}")
    if not isinstance(starting_lights_on, (float, int)):
        raise ValueError(f"starting_lights_on must be a nonnegative float or int, got {type(starting_lights_on)}")
    elif starting_lights_on < 0.0:
        raise ValueError(f"starting_lights_on must be a nonnegative float or int, got {starting_lights_on}")

    light_before = Light.RegularLight(lux=lux, 
                                        lights_on=starting_lights_on, 
                                        lights_off= np.fmod(starting_lights_on + 16.0, 24.0)
                                        )
    light_after = Light.RegularLight(lux=lux, 
                                        lights_on=np.fmod(starting_lights_on+shift, 24.0), 
                                        lights_off=np.fmod(starting_lights_on+shift+16.0, 24.0)
                                        )
    total_schedule = [light_before for _ in range(before_days-1)] + [light_after for _ in range(after_days)]
    for day in total_schedule:
        light_before = light_before.concatenate(day)
    return light_before

# %% ../nbs/01_lights.ipynb 49
@patch_to(Light)
def SocialJetlag(lux: float=150.0, # lux intensity of the light
                 num_regular_days: int=5, # number of days with a regular schedule
                 num_jetlag_days: int=2, # number of days with a delayed schedule
                 hours_delayed: float=2.0, # number of hours to delay the schedule on the jetlag days
                 regular_days_lights_on: float=7.0, # hour of the day for lights to come on
                 ) -> 'Light':
    "Create a light schedule that simulates the effects of jetlag"
    # type checking
    if not isinstance(lux, (float, int)):
        raise ValueError(f"lux must be a nonnegative float or int, got {type(lux)}")
    elif lux < 0.0:
        raise ValueError(f"lux must be a nonnegative float or int, got {lux}")
    if not isinstance(num_regular_days, int):
        raise ValueError(f"num_regular_days must be a nonnegative int, got {type(num_regular_days)}")
    elif num_regular_days < 0:
        raise ValueError(f"num_regular_days must be a nonnegative int, got {num_regular_days}")
    if not isinstance(num_jetlag_days, int):
        raise ValueError(f"num_jetlag_days must be a nonnegative int, got {type(num_jetlag_days)}")
    elif num_jetlag_days < 0:
        raise ValueError(f"num_jetlag_days must be a nonnegative int, got {num_jetlag_days}")
    if not isinstance(hours_delayed, (float, int)):
        raise ValueError(f"hours_delayed must be a nonnegative float or int, got {type(hours_delayed)}")
    elif hours_delayed < 0.0:
        raise ValueError(f"hours_delayed must be a nonnegative float or int, got {hours_delayed}")
    if not isinstance(regular_days_lights_on, (float, int)):
        raise ValueError(f"regular_days_lights_on must be a nonnegative float or int, got {type(regular_days_lights_on)}")
    elif regular_days_lights_on < 0.0:
        raise ValueError(f"regular_days_lights_on must be a nonnegative float or int, got {regular_days_lights_on}")

    jetlag_day_lights_on = (regular_days_lights_on + hours_delayed) 
    jetlag_day_lights_off = (regular_days_lights_on + 16.0 + hours_delayed) 
    regular_days = Light.RegularLight(lux=lux, lights_on=regular_days_lights_on, lights_off=regular_days_lights_on+16.0)
    jetlag_day = Light.RegularLight(lux=lux, lights_on=jetlag_day_lights_on, lights_off=jetlag_day_lights_on+16.0)
    total_schedule = [regular_days for _ in range(num_regular_days-1)] + [jetlag_day for _ in range(num_jetlag_days)]
    for day in total_schedule:
        regular_days = regular_days.concatenate(day)
        
    return regular_days

# %% ../nbs/01_lights.ipynb 52
def make_pulse(t, tstart, tend, steep: float=30.0):
    return 0.5*np.tanh(steep*(t-tstart))-0.5*np.tanh(steep*(t-tend))

def get_pulse(t: float,
              t1: float,
              t2: float,
              repeat=False,
              Intensity: float = 150.0):

    if repeat:
        t = np.fmod(t, 24.0)
    if t < 0.0:
        t += 24.0

    light_value = Intensity*make_pulse(t, t1, t2)
    return np.abs(light_value)
